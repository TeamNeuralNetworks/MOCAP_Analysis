%% Plot Phase of Response
% 	This function analyzes and plots the phase response of observed data
%   (typically neuronal spikes or instaneous firing rate) as a function of 
%   a predicted  behavioral outcome or another reference signal. It 
%   supports both event times (spikes) and continuous signals.
%
% -------------------------------------------------------------------------
%% Syntax:
% 	[mean_angle_unweighted_deg, mean_magnitude, beh_phase, n_events] = 
%       plot_phase_of_reponse(obs, pred, title_label, rendering, ref_phase, time)
%
% -------------------------------------------------------------------------
%% Inputs:
% 	obs(DOUBLE ARRAY):
%       Observed time-series data to be analyzed.
%
% 	pred(DOUBLE ARRAY):
%       Predicted time-series data or event timings (like spike times).
%
% 	title_label(CHAR):
%       Title label to be used in the plots generated by the function.
%
% 	rendering(BOOLEAN):
%       Flag indicating whether or not to render plots. 
%           * If true, plots will be generated
%           * If false, no plots will be shown
%
% 	ref_phase(DOUBLE ARRAY) - Optional:
%       Reference phase information. If not provided, it is calculated from 
%       'obs' using Hilbert transform.
%
% 	time(DOUBLE ARRAY) - Optional:
%       Time vector corresponding to 'obs' and 'pred'. If not provided, it 
%       defaults to 1:numel(obs).
%
% -------------------------------------------------------------------------
%% Outputs:
% 	mean_angle_unweighted_deg(SCALAR) DOUBLE
%       Mean angle in degrees of the phase response. 
%
% 	mean_magnitude(SCALAR) DOUBLE
%       Magnitude of the mean vector in polar coordinate system.
%
% 	beh_phase(VECTOR) DOUBLE
%       Phase information for the observed data.
%
% 	n_events(SCALAR) DOUBLE
%       Number of events (e.g., spikes) in the prediction. Returns empty if 
%       'pred' is not event-based.
%
% -------------------------------------------------------------------------
%% Extra Notes:
%
% * The function can process both event-based data and continuous signals.
% * In the case of event-based data, polar histograms are generated.
% * In the case of continuous signals, polar plots are produced.
%
% -------------------------------------------------------------------------
%% Examples:
% * Plotting spike phase
% 	[mean_angle, mean_mag, beh_phase, n_events] = 
%       plot_phase_of_reponse(obs, pred, 'Label', true);
%
% * Analyzing instaneouse firing rate (continuous signal)
% 	[mean_angle, mean_mag, beh_phase, ~] = 
%       plot_phase_of_reponse(obs, pred, 'Label', true, ref_phase);
%
% * No Rendering
% 	[mean_angle, mean_mag, beh_phase, n_events] = 
%       plot_phase_of_reponse(obs, pred, 'Label', false);
%
% -------------------------------------------------------------------------
%% Author(s):
%   Antoine Valera
%
% -------------------------------------------------------------------------
%                               Notice
%
% Notice Content will be added later. Leave a blank line here
% -------------------------------------------------------------------------
% Revision Date:
% 	20-09-202


function [mean_angle_unweighted_deg, mean_magnitude, beh_phase, n_events, time_norm] = plot_phase_of_reponse(obs, pred, title_label, rendering, ref_phase, time, time_norm)
    % Initialize defaults
    if nargin < 6 || isempty(time)
        time = 1:numel(obs);
    end    
    n_events = [];
    

    % Compute the analytic signal and phase    
    if nargin < 5 || isempty(ref_phase)

        %         analyticSignal              = hilbert(obs);
        %         beh_phase                   = angle(analyticSignal);
        % Initialize peaks and valleys
        peaks_and_valleys = {};
        [~, peaks_and_valleys{1}] = findpeaks(obs, 'MinPeakProminence', 10);
        [~, peaks_and_valleys{2}] = findpeaks(-obs, 'MinPeakProminence', 10);

        % Combine and sort peaks and valleys
        [m, firstIndex] = min([peaks_and_valleys{1}(1), peaks_and_valleys{2}(1)]);
        order = [1, 2]; % Assume peaks then valleys by default
        if firstIndex == 2
            order = [2, 1]; % Valleys then peaks
        end

        combined_locs = sort([peaks_and_valleys{order(1)}; peaks_and_valleys{order(2)}]);

        % Check for missing steps
        for i = 1:length(combined_locs)-1
            currentType = ismember(combined_locs(i), peaks_and_valleys{order(1)});
            nextType = ismember(combined_locs(i+1), peaks_and_valleys{order(1)});

            if currentType == nextType
                warning('Missing step detected near index %d', combined_locs(i));
            end
        end

        % Initialize phase array
        beh_phase = zeros(size(obs));

        % Process each segment
        for i = 1:length(combined_locs) - 1
            start_idx = combined_locs(i);
            end_idx = combined_locs(i + 1);

            % Extract the data segment
            data_segment = obs(start_idx:end_idx);

            % Normalize data segment to [0, 1]
            normalized_data_segment = (data_segment - min(data_segment)) / range(data_segment);

            % Determine if the segment is valley-to-peak or peak-to-valley
            isValleyToPeak = ismember(start_idx, peaks_and_valleys{2});

            if isValleyToPeak
                % Valley to peak: Map normalized data to phase range 0 to π
                beh_phase(start_idx:end_idx) = normalized_data_segment * pi;
            else
                % Peak to valley: Map normalized data to phase range -π to 0
                beh_phase(start_idx:end_idx) = normalized_data_segment * -pi;
            end
        end


        f                           = figure();
        href                        = polarhistogram(beh_phase, 18, 'Normalization', 'probability');
        time_norm                   = href.Values;close(f);
        mean_angle_unweighted_deg   = [];
        mean_magnitude              = [];
        return;
    else
        beh_phase = ref_phase;
    end

    if nargin < 7 || isempty(time_norm)
        time_norm = ones(1,18);
    end
    
    angles = rad2deg(beh_phase);
    
    if all(sign(diff(pred(~isnan(pred)))) >= 0)
        
        [mean_magnitude, mean_angle, n_events] = processSpikeTimes(pred, beh_phase, time, title_label, rendering, time_norm);
        mean_angle_unweighted_deg = rad2deg(mean_angle) %calculateMeanAngle(angles, pred);
    else
        mean_magnitude = processSignalPeaks(pred, angles, title_label, rendering);
        mean_angle_unweighted_deg = calculateMeanAngle(angles, pred);
    end
end

% Calculate mean angle
function mean_angle_unweighted_deg = calculateMeanAngle(angles, pred)
    mean_angle_unweighted = atan2(sum(sin(angles)) / length(angles), ...
                                  sum(cos(angles)) / length(angles));
    mean_angle_unweighted_deg = rad2deg(mean_angle_unweighted);
end

% Process spike times and plot the polar histogram
function [mean_magnitude, mean_angle, n_events] = processSpikeTimes(pred, ref_phase, time, title_label, rendering, norm)
    spike_times         = pred(1:find(~isnan(pred), 1, 'last'));
    nearest_indices     = nearestIndices(time, spike_times);
    n_events            = numel(nearest_indices);
    spike_phases        = ref_phase(nearest_indices);

    if rendering
        [mean_magnitude, mean_angle] = plotPolarHistogram(spike_phases, title_label, norm);
    end
end

% Process signal peaks
function mean_length = processSignalPeaks(pred, angles, title_label, rendering)
    [v, t_pk] = findpeaks(pred, 'MinPeakProminence', 10);
    pred = pred(t_pk);
    angles = angles(t_pk);

    if rendering
        mean_length = plotPolarPlot(angles, pred, title_label);
    else
        mean_length = nanmean(pred);
    end
end

% Get nearest indices for spike times
function nearest_indices = nearestIndices(time, spike_times)
    indices = 1:length(time);
    nearest_indices = interp1(time, indices, spike_times, 'nearest');
    nearest_indices = nearest_indices(~isnan(nearest_indices));
end

% Create polar histogram and calculate mean length
function [mean_magnitude, mean_angle] = plotPolarHistogram(spike_phases, title_label, norm)
    figure(667);clf();
    num_bins = 18;

    % Plot the polar histogram
    h = polarhistogram(spike_phases, num_bins, 'Normalization', 'probability');
    counts = h.Values ./ norm;
    edges = h.BinEdges;cla
    h = polarhistogram('BinEdges',edges,'BinCounts',counts);
    title(['Spike times as a function of Reference Phase, ', title_label]);
    
    hold on;  % Hold the current plot

    % Compute bin heights and centers
    bin_heights = h.Values;
    bin_edges = h.BinEdges;
    bin_centers = (bin_edges(1:end-1) + bin_edges(2:end)) / 2;

    % Compute the mean vector
    mean_vector_x = sum(bin_heights .* cos(bin_centers));
    mean_vector_y = sum(bin_heights .* sin(bin_centers));
    mean_magnitude = sqrt(mean_vector_x^2 + mean_vector_y^2);
    mean_angle = atan2(mean_vector_y, mean_vector_x);

    % Plot the mean vector
    polarplot([0, mean_angle], [0, mean_magnitude], 'r-', 'LineWidth', 2);  % Red arrow for average vector

    hold off;  % Release the hold
end


% Create polar plot and calculate mean length
function mean_length = plotPolarPlot(angles, pred, title_label)
    figure();
    polarplot(angles, pred, 'o-');
    title(['Event as a function of behavioural Phase, ', title_label, 'elated cell']);

    mean_vector_x = sum(pred .* cosd(angles));
    mean_vector_y = sum(pred .* sind(angles));
    mean_length = sqrt(mean_vector_x^2 + mean_vector_y^2);

    polarplot([0, atan2d(mean_vector_y, mean_vector_x)], [0, mean_length], 'r-', 'LineWidth', 2);
end
